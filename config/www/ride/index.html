<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Latest Ride</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script src="apexcharts.min.js"></script>
    <style>
      html, body {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #ffffff;
        color: #0f172a;
        font: 500 13px/1.45 "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }
      #wrap, #chart {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
      }
      .chart-tooltip {
        background: rgba(255, 255, 255, 0.95);
        color: #0f172a;
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 6px;
        padding: 8px 10px;
        font-size: 12px;
      }
      .chart-tooltip strong {
        display: block;
        margin-bottom: 4px;
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <div id="chart"></div>
    </div>
    <script>
      const JSON_URL = 'latest.json';
      const SERIES_META = [
        { key: 'power', name: 'Power', unit: 'W', color: '#f97316', opposite: false },
        { key: 'hr', name: 'Heart Rate', unit: 'bpm', color: '#ef4444', opposite: true },
        { key: 'cadence', name: 'Cadence', unit: 'rpm', color: '#2563eb', opposite: true },
      ];
      const SERIES_LOOKUP = SERIES_META.reduce((acc, meta) => {
        acc[meta.name] = meta;
        return acc;
      }, {});
      let chartInstance = null;
      let lastVersion = null;

      function toSeries(points) {
        const result = {
          power: [],
          hr: [],
          cadence: [],
        };
        for (const row of points || []) {
          if (!Array.isArray(row) || row.length < 6) continue;
          const [ts, pow, hr, cad, spd, elev] = row;
          if (!Number.isFinite(ts)) continue;
          const powVal = Number.isFinite(pow) ? Number(pow) : null;
          const hrVal = Number.isFinite(hr) ? Number(hr) : null;
          const cadVal = Number.isFinite(cad) ? Number(cad) : null;
          if (powVal === null && hrVal === null && cadVal === null) {
            continue;
          }
          const xVal = Number(ts);
          result.power.push({ x: xVal, y: powVal });
          result.hr.push({ x: xVal, y: hrVal });
          result.cadence.push({ x: xVal, y: cadVal });
        }
        return result;
      }

      function hasSeriesData(series) {
        return SERIES_META.some(meta => (series[meta.key] || []).some(point => point && point.y !== null));
      }

      function lapAnnotations() {
        return [];
      }

      async function fetchPayload(cacheBust = true) {
        const url = cacheBust ? `${JSON_URL}?_=${Date.now()}` : JSON_URL;
        const response = await fetch(url, { cache: 'no-store', credentials: 'same-origin' });
        if (!response.ok) throw new Error(`Failed to load ride data: ${response.status}`);
        return response.json();
      }

      function buildSeriesConfig(seriesMap) {
        return SERIES_META.map((meta) => {
          const data = seriesMap[meta.key] || [];
          const hasData = data.some(point => point && point.y !== null);
          const useIntegers = hasData && !data.some(point => {
            const value = point && point.y;
            return value !== null && Math.abs(value - Math.round(value)) > 1e-6;
          });
          return {
            meta,
            data,
            hasData,
            useIntegers,
          };
        }).filter(entry => entry.hasData);
      }

      function axisFormatter(useIntegers) {
        return function formatter(val) {
          const num = Number(val);
          if (!Number.isFinite(num)) return '';
          return useIntegers ? Math.round(num).toString() : num.toFixed(1);
        };
      }

      function buildOptions(series, annotations) {
        const activeSeries = buildSeriesConfig(series);
        return {
          chart: {
            type: 'line',
            height: '100%',
            animations: { enabled: true },
            toolbar: { show: true },
            zoom: { enabled: true },
            background: 'transparent',
          },
          grid: {
            borderColor: '#e2e8f0',
            row: { colors: ['#f8fafc'], opacity: 0.4 },
          },
          stroke: { width: 2, curve: 'smooth' },
          colors: activeSeries.map(entry => entry.meta.color),
          xaxis: {
            type: 'datetime',
            labels: { style: { colors: '#94a3b8' } },
          },
          yaxis: activeSeries.map((entry) => ({
            seriesName: entry.meta.name,
            title: { text: `${entry.meta.name} (${entry.meta.unit})`, style: { color: entry.meta.color } },
            labels: {
              style: { colors: entry.meta.color },
              formatter: axisFormatter(entry.useIntegers),
            },
            opposite: entry.meta.opposite,
          })),
          tooltip: {
            shared: true,
            intersect: false,
            theme: 'light',
            x: { format: 'HH:mm' },
            custom: function({ series, dataPointIndex, w }) {
              const cfgSeries = (w && w.config && Array.isArray(w.config.series)) ? w.config.series : [];
              const basePoint = cfgSeries.length && cfgSeries[0].data && cfgSeries[0].data[dataPointIndex]
                ? cfgSeries[0].data[dataPointIndex]
                : null;
              let time = 'â€”';
              if (basePoint && basePoint.x !== undefined && basePoint.x !== null) {
                const tsValue = Number(basePoint.x);
                if (Number.isFinite(tsValue)) {
                  const date = new Date(tsValue);
                  if (!Number.isNaN(date.getTime())) {
                    time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                  }
                }
              }
              let content = `<div class="chart-tooltip"><strong>${time}</strong>`;
              cfgSeries.forEach((serie, idx) => {
                const datum = serie.data && serie.data[dataPointIndex];
                const value = datum ? datum.y : null;
                if (value === null || value === undefined || Number.isNaN(value)) return;
                const label = serie.name || `Series ${idx + 1}`;
                const unit = SERIES_LOOKUP[label] ? ` ${SERIES_LOOKUP[label].unit}` : '';
                content += `<div>${label}: ${Number(value).toFixed(0)}${unit}</div>`;
              });
              return content + '</div>';
            },
          },
          annotations: { xaxis: annotations },
          series: activeSeries.map(entry => ({ name: entry.meta.name, data: entry.data })),
        };
      }

      async function initialise() {
        if (typeof ApexCharts === 'undefined') {
          console.error('ApexCharts library is missing');
          return;
        }
        try {
          const payload = await fetchPayload();
          const { title, version, points, laps } = payload || {};
          lastVersion = version || null;

          const series = toSeries(points);
          if (!hasSeriesData(series)) {
            console.warn('Ride chart: no usable data points');
            return;
          }
          const annotations = lapAnnotations(laps);
          const options = buildOptions(series, annotations);
          if (!options.series.length) {
            console.warn('Ride chart: no active series after filtering');
            return;
          }

          chartInstance = new ApexCharts(document.querySelector('#chart'), options);
          await chartInstance.render();
        } catch (err) {
          console.error(err);
        }
      }

      async function refresh() {
        if (!chartInstance) return;
        try {
          const payload = await fetchPayload();
          if (payload.version && payload.version === lastVersion) return;
          lastVersion = payload.version || lastVersion;

          const series = toSeries(payload.points);
          if (!hasSeriesData(series)) {
            console.warn('Ride chart update skipped: no usable data points');
            return;
          }
          const annotations = lapAnnotations(payload.laps);

          const activeSeries = buildSeriesConfig(series);
          if (!activeSeries.length) {
            console.warn('Ride chart update skipped: no active series');
            return;
          }
          chartInstance.updateOptions({
            annotations: { xaxis: [] },
            yaxis: activeSeries.map((entry) => ({
              seriesName: entry.meta.name,
              title: { text: `${entry.meta.name} (${entry.meta.unit})`, style: { color: entry.meta.color } },
              labels: {
                style: { colors: entry.meta.color },
                formatter: axisFormatter(entry.useIntegers),
              },
              opposite: entry.meta.opposite,
            })),
            grid: {
              borderColor: '#e2e8f0',
              row: { colors: ['#f8fafc'], opacity: 0.4 },
            },
            colors: activeSeries.map(entry => entry.meta.color),
          }, false, false);
          chartInstance.updateSeries(
            activeSeries.map(entry => ({ name: entry.meta.name, data: entry.data })),
            true
          );
        } catch (err) {
          console.error(err);
        }
      }

      initialise().then(() => window.setInterval(refresh, 10000));
    </script>
  </body>
</html>
